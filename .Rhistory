library(car)
library(dplyr)
library(ggcorrplot)
# Load the data
data("Boston", package = "MASS")
# Split the data into training and test set
# set.seed(123)
# training.samples <- Boston$medv %>%
#   createDataPartition(p = 0.8, list = FALSE)
# train.data  <- Boston[training.samples, ]
# test.data <- Boston[-training.samples, ]
head(Boston)
pred <- dplyr::select(Boston, crim:lstat)
names(pred)
cor.matrix <- cor(pred)
cor.matrix
ggcorrplot(cor.matrix)
ggcorrplot(cor.matrix, method = "circle")
ggcorrplot(cor.matrix, method = "circle", lab=TRUE)
ggcorrplot(cor.matrix, method = "circle", lab=TRUE, pch = 2)
p.mat <- (cor.matrix > 0.7)
p.mat
# Argument p.mat
# Barring the significant coefficients
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
p.mat <- (abs(cor.matrix) > 0.7)
p.mat
# Argument p.mat
# Barring the significant coefficients
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
# Build the model
model1 <- lm(medv ~ ., data = Boston)
summary(model1)
vif(model1)
pollution <- read.table("data/sulphur.dioxide.txt", header=TRUE)
pollution <- read.table("data/sulphur.dioxide.txt", header=TRUE)
pairs(pollution,panel=panel.smooth)
cor.matrix <- cor(pollution)
cor.matrix
cor.matrix <- cor(pollution)
cor.matrix
p.mat <- (abs(cor.matrix) > 0.7)
p.mat
cor.matrix <- cor(pollution)
# cor.matrix
p.mat <- (abs(cor.matrix) > 0.7)
# p.mat
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
# Build the model
model1 <- lm(Pollution ~ ., data = pollution)
summary(model1)
vif(model1)
vif(model1)
model1 <- lm(Pollution ~ Temp + Industry + Wind + Rain + Wet.days, data = pollution)
summary(model1)
vif(model1)
knitr::opts_chunk$set(echo = TRUE)
trees$Tall <- cut(trees$Height, breaks = c(-Inf, 76, Inf),
labels = c("no", "yes"))
trees$Tall[1:5]
class(trees$Tall)
treesdummy.lm <- lm(Volume ~ Girth + Tall, data = trees)
summary(treesdummy.lm)
# # we split the trees data into
# # two pieces, with groups determined by the Tall variable:
# treesTall <- split(trees, trees$Tall)
# # we add the Fitted values to each
# # piece via predict
# treesTall[["yes"]]$Fit <- predict(treesdummy.lm, treesTall[["yes"]])
# treesTall[["no"]]$Fit <- predict(treesdummy.lm, treesTall[["no"]])
# # we set up a plot for the variables Volume versus Girth
# # but we do not
# # plot anything yet (type = n) because we want to use different symbols for the two groups
# plot(Volume ~ Girth, data = trees, type = "n")
# # we add points to the plot for the Tall = yes trees and use an open circle for a plot character
# # (pch = 1), followed by points for the Tall = no trees with a triangle character (pch = 2).
# points(Volume ~ Girth, data = treesTall[["yes"]], pch = 1)
# points(Volume ~ Girth, data = treesTall[["no"]], pch = 2)
# # we add regression lines to the plot, one for each group
# lines(Fit ~ Girth, data = treesTall[["yes"]])
# lines(Fit ~ Girth, data = treesTall[["no"]])
plot(Volume ~ Girth, data = trees)
abline(a = -34, b = 4.69, col="red") # alberi bassi
abline(a = -30, b = 4.69, col="blue") # alberi alti
treesdummy.lm <- lm(Volume ~ Tall, data = trees)
summary(treesdummy.lm)
head(trees)
tall.trees <- subset(trees, trees$Tall=="yes")
small.trees <- subset(trees, trees$Tall=="no")
t.test(tall.trees$Volume, small.trees$Volume)
scores.graderA = c(4,3,4,5,2,3,4,5)
scores.graderB = c(4,4,5,5,4,5,4,4)
scores.graderC = c(3,4,2,4,5,5,4,4)
scores <- c(scores.graderA,scores.graderB,scores.graderC)
graders <- c(rep("A",8), rep("B",8), rep("C",8))
scores.graders <- data.frame(graders,scores)
boxplot(scores ~ graders, data=scores.graders)
scores.graders
scores.graderA = c(4,3,4,5,2,3,4,5)
scores.graderB = c(4,4,5,5,4,5,4,4)
scores.graderC = c(3,4,2,4,5,5,4,4)
scores <- c(scores.graderA,scores.graderB,scores.graderC)
graders <- c(rep("A",8), rep("B",8), rep("C",8))
scores.graders <- data.frame(graders,scores)
boxplot(scores ~ graders, data=scores.graders)
mod <- lm(scores ~ graders, data=scores.graders)
summary(mod)
summary(aov(scores ~ graders, data=scores.graders))
anova(lm(scores ~ graders, data=scores.graders))
oneway.test(scores ~ graders, data=scores.graders, var.equal=T) #Test whether two or more samples from normal distributions have the same means. The variances are not necessarily assumed to be equal.
oneway.test(scores ~ graders, data=scores.graders, var.equal=F) #Test whether two or more samples from normal distributions have the same means. The variances are not necessarily assumed to be equal.
data(PlantGrowth)
plant.df = PlantGrowth
plant.df$group = factor(plant.df$group, labels = c("Control", "Treatment 1", "Treatment 2"))
mod <- lm(weight ~ group, data = plant.df)
summary(mod)
plant.df$group <- relevel(plant.df$group, ref="Treatment 1")
mod <- lm(weight ~ group, data = plant.df)
summary(mod)
sand <- c(6,10,8,6,14,17,9,11,7,11)
clay <- c(17,15,3,11,14,12,12,8,10,13)
loam <- c(13,16,9,12,15,16,17,13,18,14)
dati <- data.frame(sand,clay,loam)
dati
colMeans(dati)
boxplot(dati)
soil.type <- c(rep("sand",10),
rep("clay",10),
rep("loam",10))
yields <- c(sand, clay, loam)
dati.new <- data.frame(soil.type, yields)
dati.new
by(dati.new$yields, dati.new$soil.type, var)
fligner.test(yields ~ soil.type, data=dati.new)
anova.yields <- aov(yields ~ soil.type, data=dati.new)
summary(anova.yields)
anova(lm(yields ~ soil.type, data=dati.new))
plot(anova.yields)
mod <- lm(yields ~ soil.type, data=dati.new)
summary(mod)
# Tukey Honestly Significant Differences
TukeyHSD(anova.yields) # where anova.yields comes from aov()
anova(lm(yields ~ soil.type, data=dati.new)) -> pp
(anova(lm(yields ~ soil.type, data=dati.new)) -> mod.anova)
plot(mod.anova)
plot(summary(mod.anova))
# Tukey Honestly Significant Differences
TukeyHSD(anova.yields) # where anova.yields comes from aov()
plot(TukeyHSD(anova.yields))
pairwise.t.test(dati.new$yields, dati.new$soil.type, p.adjust.method = "bonferroni")
# load the data
data(trees) # this is a dataframe
class(trees)
head(trees)
str(trees)
# histograms
hist(trees$Girth)
hist(trees$Height)
hist(trees$Volume)
# boxplots
boxplot(trees$Girth)
boxplot(trees$Height)
boxplot(trees$Volume)
# normality test
shapiro.test(trees$Girth)
qqnorm(trees$Girth); qqline(trees$Girth)
# normality test
shapiro.test(trees$Height)
qqnorm(trees$Height); qqline(trees$Height)
# normality test
shapiro.test(trees$Volume)
qqnorm(trees$Volume); qqline(trees$Volume)
data("trees")
mod <- lm(Volume ~ Girth + Height, data=trees)
summary(mod)
# the mean increase in volume when there is a one-unit increase in girth is 4.7
# Volume.tr <- trees$Volume^0.30
# mod.tr <- lm(Volume.tr ~ Girth + Height, data=trees)
# summary(mod.tr)
plot(Volume ~ Girth, data=trees)
mod.q <- lm(Volume ~ Girth + I(Girth^2) + Height + I(Height^2), data=trees)
summary(mod.q)
# alternative code:
mod.q <- lm(Volume ~ poly(Girth, 2, raw=TRUE) + poly(Height, 2, raw=TRUE), data=trees)
summary(mod.q)
plot(Volume ~ Girth, data=trees)
mod.q <- lm(Volume ~ Girth + I(Girth^2) + Height , data=trees)
summary(mod.q)
mod.int <- lm(Volume ~ Girth * Height, data=trees)
summary(mod.int)
mod <- lm(Volume ~ Girth + Height, data=trees)
plot(mod)
plot(trees$Volume ~ trees$Girth)
plot(trees$Volume ~ trees$Height)
library(sjPlot)
# plot_model(mod)
plot_model(mod, type = "eff", terms = "Girth")
plot_model(mod.int, type = "int") # # type = "int" automatically selects groups for continuous moderator variables
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int") # # type = "int" automatically selects groups for continuous moderator variables
plot_model(mod.int, type = "int", terms = c("Height","Girth") # # type = "int" automatically selects groups for continuous moderator variables
)
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int", terms = c("Height","Girth")) # # type = "int" automatically selects groups for continuous moderator variables
install.packages("effects")
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int", terms = c("Height","Girth")) # # type = "int" automatically selects groups for continuous moderator variables
effect_plot(mod.int, pred = Girth, interval = TRUE)
library(jtools)
install.packages("jtools")
library(jtools)
effect_plot(mod.int, pred = Girth, interval = TRUE)
install.packages("interactions")
