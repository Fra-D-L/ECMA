risultati.bc <- data.frame(bctrans$y, bctrans$x)
head(risultati.bc)
arrange(risultati.bc, bctrans.y)
20*6
bctrans <- boxcox(Volume^0.31 ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume^0.31 ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
bctrans <- boxcox(Volume^0.31 ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume^0.31 ~ Height + Girth, data = trees,
lambda = seq(0.1, 1.9, length = 10))
bctrans <- boxcox(Volume^0.308 ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume^0.308 ~ Height + Girth, data = trees,
lambda = seq(0.1, 1.9, length = 10))
r()
R()
Q()
t.test()
t.test(1)
t.test(c(1, 2))
t.test(c(1, 2, 1))
t.test(c(1, 2, 2, 1))
start()
?start
start(1)
start(9)
start(9); end(9)
t.test(start(9))
t.test(start(9)+1)
start(9)+1
start(9)-end(9)
5/start(9)-end(9)
5/(start(9)-end(9))
Inf
data("trees")
head(trees)
hist(trees$Volume)
hist(trees$Volume^2)
library(MASS)
?boxcox
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
max(bctrans$y)
library(dplyr)
risultati.bc <- data.frame(bctrans$y, bctrans$x)
head(risultati.bc)
arrange(risultati.bc, bctrans.y)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
max(bctrans$y)
library(dplyr)
risultati.bc <- data.frame(bctrans$y, bctrans$x)
head(risultati.bc)
arrange(risultati.bc, bctrans.y)
boxcox(Volume ~ Height + Girth, data = trees)
data("trees")
head(trees)
hist(trees$Volume)
hist(trees$Volume^2)
library(MASS)
?boxcox
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
max(bctrans$y)
library(dplyr)
risultati.bc <- data.frame(bctrans$y, bctrans$x)
head(risultati.bc)
arrange(risultati.bc, bctrans.y)
boxcox(Volume ~ Height + Girth, data = trees)
boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
which(bctrans$y==max(bctrans$y))
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
hist(trees$Volume)
hist(trees$Volume^0.31)
arrange(risultati.bc, bctrans.y)
head(risultati.bc)
plot(lm(volume ~ height+girth, dat=trees))
plot(lm(Volume ~ Height+Girth, dat=trees))
which(trees$Volume==31)
# library(tidyverse)
library(dplyr)
library(readxl)
library(HH)
library(sjPlot)
mydata <- read_excel("data/CawRidge_LifetimeData.xlsx")
ls()
mydata <- read_excel("data/CawRidge_LifetimeData.xlsx")
head(mydata)
mydata$densityYOB <- as.numeric(mydata$densityYOB)
mydata %>%
dplyr::select(densityYOB, longevity, ALR) %>%
mutate(repr = "yes") %>%
na.omit() -> mydata
knitr::opts_chunk$set(echo = TRUE)
trees$Tall <- cut(trees$Height, breaks = c(-Inf, 76, Inf),
labels = c("no", "yes"))
trees$Tall[1:5]
class(trees$Tall)
treesdummy.lm <- lm(Volume ~ Girth + Tall, data = trees)
summary(treesdummy.lm)
plot(treesdummy.lm)
treesdummy.lm <- lm(Volume ~ Tall, data = trees)
summary(treesdummy.lm)
head(trees)
tall.trees <- subset(trees, trees$Tall=="yes")
small.trees <- subset(trees, trees$Tall=="no")
t.test(tall.trees$Volume, small.trees$Volume)
treesdummy.lm <- lm(Volume ~ Tall, data = trees)
summary(treesdummy.lm)
head(trees)
tall.trees <- subset(trees, trees$Tall=="yes")
small.trees <- subset(trees, trees$Tall=="no")
t.test(tall.trees$Volume, small.trees$Volume)
tall.trees
1==2
F
F-F
T-T
T*9
T+T
F+F
0.0007138<0.05
library(ggplot2)
ggplot(df, aes(Girth, Volume, color = tall)) +
geom_point() +
geom_smooth(method = "lm", formula = y ~ x, se = FALSE)
plot(9)
plot(tall.trees$Volume, small.trees$Volume)
scores.graderA = c(4,3,4,5,2,3,4,5)
scores.graderB = c(4,4,5,5,4,5,4,4)
scores.graderC = c(3,4,2,4,5,5,4,4)
scores <- c(scores.graderA,scores.graderB,scores.graderC)
graders <- c(rep("A",8), rep("B",8), rep("C",8))
scores.graders <- data.frame(graders,scores)
boxplot(scores ~ graders, data=scores.graders)
scores.graders
mod <- lm(scores ~ graders, data=scores.graders)
summary(mod)
knitr::opts_chunk$set(echo = TRUE)
trees$Tall <- cut(trees$Height, breaks = c(-Inf, 76, Inf),
labels = c("no", "yes"))
trees$Tall[1:5]
class(trees$Tall)
treesdummy.lm <- lm(Volume ~ Girth + Tall, data = trees)
summary(treesdummy.lm)
plot(treesdummy.lm)
lmtest::bptest(treesdummy.lm)
treesdummy.lm <- lm(Volume ~ Tall, data = trees)
summary(treesdummy.lm)
head(trees)
tall.trees <- subset(trees, trees$Tall=="yes")
small.trees <- subset(trees, trees$Tall=="no")
t.test(tall.trees$Volume, small.trees$Volume)
boxcox(treesdummy.lm)
library(MASS)
boxcox(treesdummy.lm)
boxcox(treesdummy.lm, lambda = seq(-2, 2, 0.1))$x[which.max(bc$y)]
boxcox(treesdummy.lm, lambda = seq(-2, 2, 0.1))$x[which.max(boxcox(treesdummy.lm, lambda = seq(-2, 2, 0.1))$y)]
data("trees")
head(trees)
hist(trees$Volume)
hist(trees$Volume^2)
library(MASS)
?boxcox
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
max(bctrans$y)
library(dplyr)
risultati.bc <- data.frame(bctrans$y, bctrans$x)
head(risultati.bc)
arrange(risultati.bc, bctrans.y)
bctrans$y %>% which.max() %>% bctrans$x[]
bctrans$x[bctrans$y %>% which.max()]
temp <- -0.02020202
q()
data("trees")
head(trees)
hist(trees$Volume)
hist(trees$Volume^2)
library(MASS)
?boxcox
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
max(bctrans$y)
library(dplyr)
risultati.bc <- data.frame(bctrans$y, bctrans$x)
head(risultati.bc)
arrange(risultati.bc, bctrans.y)
boxcox(treesdummy.lm)
knitr::opts_chunk$set(echo = TRUE)
trees$Tall <- cut(trees$Height, breaks = c(-Inf, 76, Inf),
labels = c("no", "yes"))
trees$Tall[1:5]
class(trees$Tall)
treesdummy.lm <- lm(Volume ~ Girth + Tall, data = trees)
summary(treesdummy.lm)
treesdummy.lm <- lm(Volume ~ Tall, data = trees)
summary(treesdummy.lm)
head(trees)
tall.trees <- subset(trees, trees$Tall=="yes")
small.trees <- subset(trees, trees$Tall=="no")
t.test(tall.trees$Volume, small.trees$Volume)
boxcox(treesdummy.lm)
boxcox(treesdummy.lm) -> temp
temp$x[temp$y %>% which.max()]
temp$x[temp$y %>% which.max()] -> lam
trees$Volume^lam
hist(trees$Volume); hist(trees$Volume^lam)
trees$Volume^lam %>% boxcox()
boxcox(trees$volume^lam)
boxcox(trees$Volume^lam)
trees
boxcox(Volume^lam, data = trees)
trees$Volume
data(PlantGrowth)
plant.df = PlantGrowth
plant.df$group = factor(plant.df$group, labels = c("Control", "Treatment 1", "Treatment 2"))
plant.df
sort_by(plant.df, weight)
view(plant.df)
library(tidyverse)
view(plant.df)
sort_by(plant.df, weight)
boxplot(plant.df)
summary(plant.df$group)
boxplot(plant.df$weight)
str(plant.df)
hist(plant.df$weight)
shapiro.test(plant.df$weight)
qqnorm(plant.df$weight); qqline(plant.df$weight)
boxplot(weight ~ group, data=plant.df)
shapiro.test(plant.df$weight)
lm(plant.df)
lm(weight ~ group, data=plant.df)
plant.lm <- lm(weight ~ group, data=plant.df)
plot(plant.lm)
type(plant.df$group)
library(tidyverse)
type(plant.df$group)
clss(plant.df$group)
class(plant.df$group)
levels(plant.df$group)
aov(plant.lm)
weight~group
prop <- weight~group
prop
plant.df$weight ~ plant.df$group
class prop
class(prop)
prop <- plant.df$weight ~ plant.df$group
aov(prop, data=trees)
plant.df$group <- relevel(plant.df$group, ref="Treatment 1")
plant.df$group
plant.df
aov(prop, data=trees) %>% summary()
aov(prop, data=trees)
bctrans$x[which.max(bctrans$y)]
weights <- read.csv("data/growth2.txt", sep="\t")
head(weights)
library(tidyverse)
factors(weights)
factor(weights)
factor(weights$diet)
factor(weights$diet) %>% unique()
factor(weights$supplement) %>% unique()
factor(weights$gain) %>% unique()
view(weights)
summary(weights)
weights$supplement <- factor(weights$supplement)
weights$diet <- factor(weights$diet)
summary(weights)
view(weights)
head(weights)
with(weights,
coplot(gain ~ diet|supplement,rows=2))
with(weights,
coplot(gain ~ diet|supplement,rows=2))
with(weights,
coplot(gain ~ diet|supplement,rows=2))
plot(gain ~ diet)
plot(gain~diet)
with(weights,
coplot(gain ~ diet|supplement,rows=2))
plot(gain~diet, data=weights)
plot(gain~supplements, data=weights)
plot(gain~supplement, data=weights)
aov(gain~diet*supplement, data = weights); aov(gain~diet+supplement, data = weights)
aov(gain~diet*supplement, data = weights)
model<-aov(gain~diet*supplement, data = weights)
summary(model)
weights$diet <- relevel(weights$diet, ref="oats")
with(weights, interaction.plot(diet,supplement, response = gain))
summary.lm(model)
summary.lm(model2)
model2 <- aov(gain~diet + supplement, data = weights)
summary(model2)
summary.lm(model2)
anova(model,model2)
TukeyHSD(model2)
plot(TukeyHSD(model2))
library(sjPlot)
# plot_model(model2, type = "diag")
plot_model(model2, type="eff")
# plot_model(model2, type = "diag")
plot_model(model2, type="eff")
data(iris)
head(iris)
fitiris <- lm(Petal.Length ~ Petal.Width * Species, data = iris)
library(jtools)
plot_model(fitiris, type="int")
plot_model(fitiris, type="est")
plot_model(fitiris, type="re")
plot_model(fitiris, type="eff")
plot_model(fitiris, type="emm")
plot_model(fitiris, type="pred")
plot_model(fitiris, type="int")
plot_model(fitiris, type="std")
plot_model(fitiris, type="std2")
plot_model(fitiris, type="diag")
?`^`
?sample
sample(adulti)
sample(adulti, 20)
sample(adulti, 9)
library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization
library(FactoMineR)
library(readxl)
library(readr)
df
# You could also plot the convex hulls, ellipses, spider plots, etc. colored based on the treatments
# First, create a vector of color values corresponding of the same length as the vector of treatment values
colors=c(rep("red",5),rep("blue",5))
ordiplot(example_NMDS,type="n")
# Non-metric multidimensional scaling (NMDS) is one tool commonly used to
# examine community composition
# # Let's lay some conceptual groundwork
# Consider a single axis of abundance representing a single species:
plot(0:10,0:10,type="n",axes=F,xlab="Abundance of Species 1",ylab="")
axis(1)
# We can plot each community on that axis depending on the abundance of
# species 1 within it
points(5,0); text(5.5,0.5,labels="community A")
points(3,0); text(3.2,0.5,labels="community B")
points(0,0); text(0.8,0.5,labels="community C")
#
# # Now consider a second axis of abundance representing a different
# # species
# # Communities can be plotted along both axes depending on the abundance of
# # species within it
plot(0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2")
points(5,5); text(5,4.5,labels="community A")
points(3,3); text(3,3.5,labels="community B")
points(0,5); text(0.8,5.5,labels="community C")
# Now consider a THIRD axis of abundance representing yet another species
# (For this we're going to need to load another package)
# install.packages("scatterplot3d")
library(scatterplot3d)
d=scatterplot3d(0:10,0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2",
zlab="Abundance of Species 3"); d
d$points3d(5,5,0); text(d$xyz.convert(5,5,0.5),labels="community A")
d$points3d(3,3,3); text(d$xyz.convert(3,3,3.5),labels="community B")
d$points3d(0,5,5); text(d$xyz.convert(0,5,5.5),labels="community C")
# Now consider as many axes as there are species S (obviously we cannot
# visualize this beyond 3 dimensions)
# Hopefully your head didn't explode
# The goal of NMDS is to represent the original position of communities in
# multidimensional space as accurately as possible using a reduced number
# of dimensions that can be easily plotted and visualized
# NMDS does not use the absolute abundances of species in communities, but
# rather their RANK ORDER!
# The use of ranks omits some of the issues associated with using absolute
# distance (e.g., sensitivity to transformation), and as a result is much
# more flexible technique that accepts a variety of types of data
# (It is also where the "non-metric" part of the name comes from)
# The NMDS procedure is iterative and takes place over several steps:
# (1) Define the original positions of communities in multidimensional space
# (2) Specify the number m of reduced dimensions (typically 2)
# (3) Construct an initial configuration of the samples in 2-dimensions
# (4) Regress distances in this initial configuration against the observed
# (measured) distances
# (5) Determine the stress (disagreement between 2-D configuration and
# predicted values from regression)
# If the 2-D configuration perfectly preserves the original rank
# orders, then a plot ofone against the other must be monotonically
# increasing. The extent to which the points on the 2-D configuration
# differ from this monotonically increasing line determines the
# degree of stress (see Shepard plot)
# (6) If stress is high, reposition the points in m dimensions in the
#direction of decreasing stress, and repeat until stress is below
#some threshold
# Generally, stress < 0.05 provides an excellent represention in reduced dimensions, < 0.1 is great, < 0.2 is good, and stress > 0.3 provides a poor representation
# NOTE: The final configuration may differ depending on the initial
# configuration (which is often random) and the number of iterations, so
# it is advisable to run the NMDS multiple times and compare the
# interpretation from the lowest stress solutions
# To begin, NMDS requires a distance matrix, or a matrix of
# dissimilarities
# Raw Euclidean distances are not ideal for this purpose: they are
# sensitive to total abundances, so may treat sites with a similar number
# of species as more similar, even though the identities of the species
# are different
# They are also sensitive to species absences, so may treat sites with
# the same number of absent species as more similar
# Consequently, ecologists use the Bray-Curtis dissimilarity calculation,
# which has many ideal properties:
# It is invariant to changes in units
# It is unaffected by additions/removals of species that are not
# present in two communities
# It is unaffected by the addition of a new community
# It can recognize differences in total abudnances when relative
# abundances are the same
# To run the NMDS, we will use the function `metaMDS` from the vegan
# package
#install.packages("vegan")
library(vegan)
# `metaMDS` requires a community-by-species matrix
# Let's create that matrix with some randomly sampled data
set.seed(2)
community_matrix=matrix(sample(1:100,300,replace=T),nrow=10,
dimnames=list(paste("community",1:10,sep=""),
paste("sp",1:30,sep="")))
community_matrix
# The function `metaMDS` will take care of most of the distance
# calculations, iterative fitting, etc. We need simply to supply:
example_NMDS=metaMDS(community_matrix, # Our community-by-species matrix
k=2) # The number of reduced dimensions
# You should see each iteration of the NMDS until a solution is reached
# (i.e., stress was minimized after some number of reconfigurations of
# the points in 2 dimensions). You can increase the number of default
# iterations using the argument "trymax=##"
example_NMDS=metaMDS(community_matrix,k=2,trymax=100)
# And we can look at the NMDS object
example_NMDS # metaMDS has automatically applied a square root
# transformation and calculated the Bray-Curtis distances for our
# community-by-site matrix
# Let's examine a Shepard plot, which shows scatter around the regression
# between the interpoint distances in the final configuration (distances
# between each pair of communities) against their original dissimilarities
stressplot(example_NMDS)
# Large scatter around the line suggests that original dissimilarities are
# not well preserved in the reduced number of dimensions
library(tidyverse)
sand <- c(6,10,8,6,14,17,9,11,7,11)
clay <- c(17,15,3,11,14,12,12,8,10,13)
loam <- c(13,16,9,12,15,16,17,13,18,14)
dati <- data.frame(sand,clay,loam)
dati
colMeans(dati)
boxplot(dati)
soil.type <- c(rep("sand",10),
rep("clay",10),
rep("loam",10))
yields <- c(sand, clay, loam)
dati.new <- data.frame(soil.type, yields)
dati.new
by(dati.new$yields, dati.new$soil.type, var)
fligner.test(yields ~ soil.type, data=dati.new)
anova.yields <- aov(yields ~ soil.type, data=dati.new)
summary(anova.yields)
anova(lm(yields ~ soil.type, data=dati.new))
mod <- lm(yields ~ soil.type, data=dati.new)
summary(mod)
dati.relevel <- dati.new
dati.relevel$soil.type <- relevel(dati.relevel$soil.type, ref="sand")
dati.relevel <- dati.new
dati.relevel$soil.type <- relevel(as.factor(dati.relevel$soil.type), ref="sand")
mod.relevel <- lm(yields ~ soil.type, data=dati.relevel)
summary(mod.relevel)
# Tukey Honestly Significant Differences
TukeyHSD(anova.yields) # where anova.yields comes from aov()
plot(TukeyHSD(anova.yields))
pairwise.t.test(dati.new$yields, dati.new$soil.type, p.adjust.method = "bonferroni")
by(dati.new$yields, dati.new$soil.type, var)
fligner.test(yields ~ soil.type, data=dati.new)
