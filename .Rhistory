# treesTall[["no"]]$Fit <- predict(treesdummy.lm, treesTall[["no"]])
# # we set up a plot for the variables Volume versus Girth
# # but we do not
# # plot anything yet (type = n) because we want to use different symbols for the two groups
# plot(Volume ~ Girth, data = trees, type = "n")
# # we add points to the plot for the Tall = yes trees and use an open circle for a plot character
# # (pch = 1), followed by points for the Tall = no trees with a triangle character (pch = 2).
# points(Volume ~ Girth, data = treesTall[["yes"]], pch = 1)
# points(Volume ~ Girth, data = treesTall[["no"]], pch = 2)
# # we add regression lines to the plot, one for each group
# lines(Fit ~ Girth, data = treesTall[["yes"]])
# lines(Fit ~ Girth, data = treesTall[["no"]])
plot(Volume ~ Girth, data = trees)
abline(a = -34, b = 4.69, col="red") # alberi bassi
abline(a = -30, b = 4.69, col="blue") # alberi alti
treesdummy.lm <- lm(Volume ~ Tall, data = trees)
summary(treesdummy.lm)
head(trees)
tall.trees <- subset(trees, trees$Tall=="yes")
small.trees <- subset(trees, trees$Tall=="no")
t.test(tall.trees$Volume, small.trees$Volume)
scores.graderA = c(4,3,4,5,2,3,4,5)
scores.graderB = c(4,4,5,5,4,5,4,4)
scores.graderC = c(3,4,2,4,5,5,4,4)
scores <- c(scores.graderA,scores.graderB,scores.graderC)
graders <- c(rep("A",8), rep("B",8), rep("C",8))
scores.graders <- data.frame(graders,scores)
boxplot(scores ~ graders, data=scores.graders)
scores.graders
scores.graderA = c(4,3,4,5,2,3,4,5)
scores.graderB = c(4,4,5,5,4,5,4,4)
scores.graderC = c(3,4,2,4,5,5,4,4)
scores <- c(scores.graderA,scores.graderB,scores.graderC)
graders <- c(rep("A",8), rep("B",8), rep("C",8))
scores.graders <- data.frame(graders,scores)
boxplot(scores ~ graders, data=scores.graders)
mod <- lm(scores ~ graders, data=scores.graders)
summary(mod)
summary(aov(scores ~ graders, data=scores.graders))
anova(lm(scores ~ graders, data=scores.graders))
oneway.test(scores ~ graders, data=scores.graders, var.equal=T) #Test whether two or more samples from normal distributions have the same means. The variances are not necessarily assumed to be equal.
oneway.test(scores ~ graders, data=scores.graders, var.equal=F) #Test whether two or more samples from normal distributions have the same means. The variances are not necessarily assumed to be equal.
data(PlantGrowth)
plant.df = PlantGrowth
plant.df$group = factor(plant.df$group, labels = c("Control", "Treatment 1", "Treatment 2"))
mod <- lm(weight ~ group, data = plant.df)
summary(mod)
plant.df$group <- relevel(plant.df$group, ref="Treatment 1")
mod <- lm(weight ~ group, data = plant.df)
summary(mod)
sand <- c(6,10,8,6,14,17,9,11,7,11)
clay <- c(17,15,3,11,14,12,12,8,10,13)
loam <- c(13,16,9,12,15,16,17,13,18,14)
dati <- data.frame(sand,clay,loam)
dati
colMeans(dati)
boxplot(dati)
soil.type <- c(rep("sand",10),
rep("clay",10),
rep("loam",10))
yields <- c(sand, clay, loam)
dati.new <- data.frame(soil.type, yields)
dati.new
by(dati.new$yields, dati.new$soil.type, var)
fligner.test(yields ~ soil.type, data=dati.new)
anova.yields <- aov(yields ~ soil.type, data=dati.new)
summary(anova.yields)
anova(lm(yields ~ soil.type, data=dati.new))
plot(anova.yields)
mod <- lm(yields ~ soil.type, data=dati.new)
summary(mod)
# Tukey Honestly Significant Differences
TukeyHSD(anova.yields) # where anova.yields comes from aov()
anova(lm(yields ~ soil.type, data=dati.new)) -> pp
(anova(lm(yields ~ soil.type, data=dati.new)) -> mod.anova)
plot(mod.anova)
plot(summary(mod.anova))
# Tukey Honestly Significant Differences
TukeyHSD(anova.yields) # where anova.yields comes from aov()
plot(TukeyHSD(anova.yields))
pairwise.t.test(dati.new$yields, dati.new$soil.type, p.adjust.method = "bonferroni")
# load the data
data(trees) # this is a dataframe
class(trees)
head(trees)
str(trees)
# histograms
hist(trees$Girth)
hist(trees$Height)
hist(trees$Volume)
# boxplots
boxplot(trees$Girth)
boxplot(trees$Height)
boxplot(trees$Volume)
# normality test
shapiro.test(trees$Girth)
qqnorm(trees$Girth); qqline(trees$Girth)
# normality test
shapiro.test(trees$Height)
qqnorm(trees$Height); qqline(trees$Height)
# normality test
shapiro.test(trees$Volume)
qqnorm(trees$Volume); qqline(trees$Volume)
data("trees")
mod <- lm(Volume ~ Girth + Height, data=trees)
summary(mod)
# the mean increase in volume when there is a one-unit increase in girth is 4.7
# Volume.tr <- trees$Volume^0.30
# mod.tr <- lm(Volume.tr ~ Girth + Height, data=trees)
# summary(mod.tr)
plot(Volume ~ Girth, data=trees)
mod.q <- lm(Volume ~ Girth + I(Girth^2) + Height + I(Height^2), data=trees)
summary(mod.q)
# alternative code:
mod.q <- lm(Volume ~ poly(Girth, 2, raw=TRUE) + poly(Height, 2, raw=TRUE), data=trees)
summary(mod.q)
plot(Volume ~ Girth, data=trees)
mod.q <- lm(Volume ~ Girth + I(Girth^2) + Height , data=trees)
summary(mod.q)
mod.int <- lm(Volume ~ Girth * Height, data=trees)
summary(mod.int)
mod <- lm(Volume ~ Girth + Height, data=trees)
plot(mod)
plot(trees$Volume ~ trees$Girth)
plot(trees$Volume ~ trees$Height)
library(sjPlot)
# plot_model(mod)
plot_model(mod, type = "eff", terms = "Girth")
plot_model(mod.int, type = "int") # # type = "int" automatically selects groups for continuous moderator variables
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int") # # type = "int" automatically selects groups for continuous moderator variables
plot_model(mod.int, type = "int", terms = c("Height","Girth") # # type = "int" automatically selects groups for continuous moderator variables
)
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int", terms = c("Height","Girth")) # # type = "int" automatically selects groups for continuous moderator variables
install.packages("effects")
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int", terms = c("Height","Girth")) # # type = "int" automatically selects groups for continuous moderator variables
effect_plot(mod.int, pred = Girth, interval = TRUE)
library(jtools)
install.packages("jtools")
library(jtools)
effect_plot(mod.int, pred = Girth, interval = TRUE)
install.packages("interactions")
>>>>>>> dd5d35c6cba93aff042b4e71fb56d3cb24b536b4
knitr::opts_chunk$set(echo = TRUE)
res.prcomp <- prcomp(iris[,-5])
iris[,-5]
iris
res.prcomp <- prcomp(iris[,-5])
summary(res.prcomp)
# compare to:
res.prcomp <- prcomp(iris[,-5], center=TRUE, scale=TRUE)
summary(res.prcomp)
summary(res.prcomp)
plot(res.prcomp)
res.prcomp <- prcomp(iris[,-5])
summary(res.prcomp)
plot(res.prcomp)
res.prcomp <- prcomp(iris[,-5])
summary(res.prcomp)
# compare to:
res.prcomp <- prcomp(iris[,-5], center=TRUE, scale=TRUE)
summary(res.prcomp)
plot(res.prcomp)
biplot(res.prcomp)
res.prcomp$rotation
biplot(res.prcomp)
res.prcomp$rotation
biplot(res.prcomp, choices=3:4)
res.princomp <- princomp(iris[,-5])
summary(res.princomp)
res.princomp <- princomp(iris[,-5], cor=TRUE)
summary(res.princomp)
loadings(res.princomp) # Small loadings are conventionally not printed (replaced by spaces), to draw the eye to the pattern of the larger loadings.
plot(res.princomp)
biplot(res.princomp)
library(FactoMineR)
library(factoextra)
res.pca <- PCA(iris[, -5],  graph = FALSE)
res.pca
get_eig(res.pca) # Extract eigenvalues/variances
plot(res.princomp)
# Visualize eigenvalues/variances
fviz_eig(res.pca, addlabels=TRUE, hjust = -0.3)+
theme_minimal()
# Extract the results for variables
var <- get_pca_var(res.pca)
var
# Contribution of variables
var$contrib
colSums(var$contrib)
# correlation of variables with the first 4 PC
res.pca$var$cor[, 1:4]
# axis characterization
dimdesc(res.pca)
# Graph of variables: default plot
fviz_pca_var(res.pca, col.var = "steelblue")
# It’s possible to control variable colors using their contributions to the principal axes:
# Control variable colors using their contributions
# Use gradient color
fviz_pca_var(res.pca, col.var="contrib")+
scale_color_gradient2(low="white", mid="blue",
high="red", midpoint = 96) +
theme_minimal()
# Graph of variables: default plot
fviz_pca_var(res.pca, col.var = "steelblue")
# It’s possible to control variable colors using their contributions to the principal axes:
# Control variable colors using their contributions
# Use gradient color
fviz_pca_var(res.pca, col.var="contrib")+
scale_color_gradient2(low="white", mid="blue",
high="red", midpoint = 96) +
theme_minimal()
# Variable contributions on axis 1
fviz_contrib(res.pca, choice="var", axes = 1 )+
labs(title = "Contributions to Dim 1")
# Variable contributions on axis 2
fviz_contrib(res.pca, choice="var", axes = 2 )+
labs(title = "Contributions to Dim 2")
# Variable contributions on axes 1 + 2
fviz_contrib(res.pca, choice="var", axes = 1:2)+
labs(title = "Contributions to Dim 1+2")
res.pca
res.pca
fviz_pca_var(res.pca, col.var="contrib")+
scale_color_gradient2(low="white", mid="blue",
high="red") +
theme_minimal()
# It’s possible to control variable colors using their contributions to the principal axes:
# Control variable colors using their contributions
# Use gradient color
fviz_pca_var(res.pca, col.var="contrib")+
scale_color_gradient2(low="white", mid="blue",
high="red", midpoint = 25) +
theme_minimal()
# Variable contributions on axis 1
fviz_contrib(res.pca, choice="var", axes = 1 )+
labs(title = "Contributions to Dim 1")
# Variable contributions on axis 2
fviz_contrib(res.pca, choice="var", axes = 2 )+
labs(title = "Contributions to Dim 2")
# Graph of variables: default plot
fviz_pca_var(res.pca, col.var = "steelblue")
# It’s possible to control variable colors using their contributions to the principal axes:
# Control variable colors using their contributions
# Use gradient color
fviz_pca_var(res.pca, col.var="contrib")+
scale_color_gradient2(low="white", mid="blue",
high="red", midpoint = 25) +
theme_minimal()
# Variable contributions on axis 1
fviz_contrib(res.pca, choice="var", axes = 1 )+
labs(title = "Contributions to Dim 1")
# Variable contributions on axis 2
fviz_contrib(res.pca, choice="var", axes = 2 )+
labs(title = "Contributions to Dim 2")
# Variable contributions on axes 1 + 2
fviz_contrib(res.pca, choice="var", axes = 1:2)+
labs(title = "Contributions to Dim 1+2")
# Extract the results for individuals
ind <- get_pca_ind(res.pca)
ind
# Coordinates of individuals
head(ind$coord)
# compare to:
head(res.prcomp$x)
# Graph of individuals
# 1. Use repel = TRUE to avoid overplotting
fviz_pca_ind(res.pca, repel = TRUE)+
theme_minimal()
# Color by groups: habillage=iris$Species
# Show points only: geom = "point"
p <- fviz_pca_ind(res.pca, geom = "point",
habillage=iris$Species, addEllipses=TRUE,
ellipse.level= 0.95)+ theme_minimal()
print(p)
# Change group colors manually
# Read more: http://www.sthda.com/english/wiki/ggplot2-colors
p + scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
theme_minimal()
# Biplot of individuals and variables
# ++++++++++++++++++++++++++
# Only variables are labelled
fviz_pca_biplot(res.pca,  label="var", habillage=iris$Species,
addEllipses=TRUE, ellipse.level=0.95) +
theme_minimal()
# Non-metric multidimensional scaling (NMDS) is one tool commonly used to
# examine community composition
# # Let's lay some conceptual groundwork
# # Consider a single axis of abundance representing a single species:
# plot(0:10,0:10,type="n",axes=F,xlab="Abundance of Species 1",ylab="")
# axis(1)
# # We can plot each community on that axis depending on the abundance of
# # species 1 within it
# points(5,0); text(5.5,0.5,labels="community A")
# points(3,0); text(3.2,0.5,labels="community B")
# points(0,0); text(0.8,0.5,labels="community C")
#
# # Now consider a second axis of abundance representing a different
# # species
# # Communities can be plotted along both axes depending on the abundance of
# # species within it
plot(0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2")
points(5,5); text(5,4.5,labels="community A")
points(3,3); text(3,3.5,labels="community B")
points(0,5); text(0.8,5.5,labels="community C")
# Now consider a THIRD axis of abundance representing yet another species
# (For this we're going to need to load another package)
# install.packages("scatterplot3d")
library(scatterplot3d)
d=scatterplot3d(0:10,0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2",
zlab="Abundance of Species 3"); d
d$points3d(5,5,0); text(d$xyz.convert(5,5,0.5),labels="community A")
d$points3d(3,3,3); text(d$xyz.convert(3,3,3.5),labels="community B")
d$points3d(0,5,5); text(d$xyz.convert(0,5,5.5),labels="community C")
# Now consider as many axes as there are species S (obviously we cannot
# visualize this beyond 3 dimensions)
# Hopefully your head didn't explode
# Consider a single axis of abundance representing a single species:
plot(0:10,0:10,type="n",axes=F,xlab="Abundance of Species 1",ylab="")
axis(1)
# We can plot each community on that axis depending on the abundance of
# species 1 within it
points(5,0); text(5.5,0.5,labels="community A")
points(3,0); text(3.2,0.5,labels="community B")
points(0,0); text(0.8,0.5,labels="community C")
# Non-metric multidimensional scaling (NMDS) is one tool commonly used to
# examine community composition
# # Let's lay some conceptual groundwork
# Consider a single axis of abundance representing a single species:
plot(0:10,0:10,type="n",axes=F,xlab="Abundance of Species 1",ylab="")
axis(1)
# We can plot each community on that axis depending on the abundance of
# species 1 within it
points(5,0); text(5.5,0.5,labels="community A")
points(3,0); text(3.2,0.5,labels="community B")
points(0,0); text(0.8,0.5,labels="community C")
#
# # Now consider a second axis of abundance representing a different
# # species
# # Communities can be plotted along both axes depending on the abundance of
# # species within it
plot(0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2")
points(5,5); text(5,4.5,labels="community A")
points(3,3); text(3,3.5,labels="community B")
points(0,5); text(0.8,5.5,labels="community C")
# Now consider a THIRD axis of abundance representing yet another species
# (For this we're going to need to load another package)
# install.packages("scatterplot3d")
library(scatterplot3d)
d=scatterplot3d(0:10,0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2",
zlab="Abundance of Species 3"); d
d$points3d(5,5,0); text(d$xyz.convert(5,5,0.5),labels="community A")
d$points3d(3,3,3); text(d$xyz.convert(3,3,3.5),labels="community B")
d$points3d(0,5,5); text(d$xyz.convert(0,5,5.5),labels="community C")
# Now consider as many axes as there are species S (obviously we cannot
# visualize this beyond 3 dimensions)
# Hopefully your head didn't explode
# To run the NMDS, we will use the function `metaMDS` from the vegan
# package
#install.packages("vegan")
library(vegan)
# `metaMDS` requires a community-by-species matrix
# Let's create that matrix with some randomly sampled data
set.seed(2)
# The goal of NMDS is to represent the original position of communities in
# multidimensional space as accurately as possible using a reduced number
# of dimensions that can be easily plotted and visualized
# NMDS does not use the absolute abundances of species in communities, but
# rather their RANK ORDER!
# The use of ranks omits some of the issues associated with using absolute
# distance (e.g., sensitivity to transformation), and as a result is much
# more flexible technique that accepts a variety of types of data
# (It is also where the "non-metric" part of the name comes from)
# The NMDS procedure is iterative and takes place over several steps:
# (1) Define the original positions of communities in multidimensional space
# (2) Specify the number m of reduced dimensions (typically 2)
# (3) Construct an initial configuration of the samples in 2-dimensions
# (4) Regress distances in this initial configuration against the observed
# (measured) distances
# (5) Determine the stress (disagreement between 2-D configuration and
# predicted values from regression)
# If the 2-D configuration perfectly preserves the original rank
# orders, then a plot ofone against the other must be monotonically
# increasing. The extent to which the points on the 2-D configuration
# differ from this monotonically increasing line determines the
# degree of stress (see Shepard plot)
# (6) If stress is high, reposition the points in m dimensions in the
#direction of decreasing stress, and repeat until stress is below
#some threshold
# Generally, stress < 0.05 provides an excellent represention in reduced dimensions, < 0.1 is great, < 0.2 is good, and stress > 0.3 provides a poor representation
# NOTE: The final configuration may differ depending on the initial
# configuration (which is often random) and the number of iterations, so
# it is advisable to run the NMDS multiple times and compare the
# interpretation from the lowest stress solutions
# To begin, NMDS requires a distance matrix, or a matrix of
# dissimilarities
# Raw Euclidean distances are not ideal for this purpose: they are
# sensitive to total abundances, so may treat sites with a similar number
# of species as more similar, even though the identities of the species
# are different
# They are also sensitive to species absences, so may treat sites with
# the same number of absent species as more similar
# Consequently, ecologists use the Bray-Curtis dissimilarity calculation,
# which has many ideal properties:
# It is invariant to changes in units
# It is unaffected by additions/removals of species that are not
# present in two communities
# It is unaffected by the addition of a new community
# It can recognize differences in total abudnances when relative
# abundances are the same
# To run the NMDS, we will use the function `metaMDS` from the vegan
# package
#install.packages("vegan")
library(vegan)
# `metaMDS` requires a community-by-species matrix
# Let's create that matrix with some randomly sampled data
set.seed(2)
community_matrix=matrix(sample(1:100,300,replace=T),nrow=10,
dimnames=list(paste("community",1:10,sep=""),
paste("sp",1:30,sep="")))
community_matrix
# The function `metaMDS` will take care of most of the distance
# calculations, iterative fitting, etc. We need simply to supply:
example_NMDS=metaMDS(community_matrix, # Our community-by-species matrix
k=2) # The number of reduced dimensions
# You should see each iteration of the NMDS until a solution is reached
# (i.e., stress was minimized after some number of reconfigurations of
# the points in 2 dimensions). You can increase the number of default
# iterations using the argument "trymax=##"
example_NMDS=metaMDS(community_matrix,k=2,trymax=100)
# And we can look at the NMDS object
example_NMDS # metaMDS has automatically applied a square root
# transformation and calculated the Bray-Curtis distances for our
# community-by-site matrix
# Let's examine a Shepard plot, which shows scatter around the regression
# between the interpoint distances in the final configuration (distances
# between each pair of communities) against their original dissimilarities
stressplot(example_NMDS)
# Large scatter around the line suggests that original dissimilarities are
# not well preserved in the reduced number of dimensions
#Now we can plot the NMDS
plot(example_NMDS)
# We can use the functions `ordiplot` and `orditorp` to add text to the
# plot in place of points
ordiplot(example_NMDS,type="n")
#Now we can plot the NMDS
plot(example_NMDS)
# It shows us both the communities ("sites", open circles) and species
# (red crosses), but we  don't know which are which!
# We can use the functions `ordiplot` and `orditorp` to add text to the
# plot in place of points
ordiplot(example_NMDS,type="n")
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",cex=1.25,air=0.01)
# There are some additional functions that might of interest
# Let's suppose that communities 1-5 had some treatment applied, and
# communities 6-10 a different treatment
# We can draw convex hulls connecting the vertices of the points made by
# these communities on the plot
# First, let's create a vector of treatment values:
treat=c(rep("Treatment1",5),rep("Treatment2",5))
ordiplot(example_NMDS,type="n")
ordihull(example_NMDS,groups=treat,draw="polygon",col="grey90",
label=FALSE)
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",col=c(rep("green",5),rep("blue",5)),
air=0.01,cex=1.25)
# I find this an intuitive way to understand how communities and species
# cluster based on treatments
# One can also plot ellipses and "spider graphs" using the functions
# `ordiellipse` and `orderspider` which emphasize the centroid of the
# communities in each treatment
# Another alternative is to plot a minimum spanning tree (from the
# function `hclust`), which clusters communities based on their original
# dissimilarities and projects the dendrogram onto the 2-D plot
ordiplot(example_NMDS,type="n")
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",col=c(rep("green",5),rep("blue",5)),
air=0.01,cex=1.25)
ordicluster(example_NMDS,hclust(vegdist(community_matrix,"bray")))
# Note that clustering is based on Bray-Curtis distances
# This is one method suggested to check the 2-D plot for accuracy
# You could also plot the convex hulls, ellipses, spider plots, etc. colored based on the treatments
# First, create a vector of color values corresponding of the same length as the vector of treatment values
colors=c(rep("red",5),rep("blue",5))
ordiplot(example_NMDS,type="n")
#Plot convex hulls with colors baesd on treatment
for(i in unique(treat)) {
ordihull(example_NMDS$point[grep(i,treat),],draw="polygon",groups=treat[treat==i],col=colors[grep(i,treat)],label=F) }
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",col=c(rep("green",5),rep("blue",5)),
air=0.01,cex=1.25)
ordiellipse(example_NMDS$point[grep(i,treat),],   groups=treat[treat==i], col=colors[grep(i,treat)],label=F, display="sites", kind = c("sd","se", "ehull"),
conf, draw = c("lines","polygon"),
w = weights(ord, display), col = NULL, alpha = 127, show.groups,
label = FALSE, border = NULL, lty = NULL, lwd=NULL)}
for(i in unique(treat)) {
ordiellipse(example_NMDS$point[grep(i,treat),],   groups=treat[treat==i], col=colors[grep(i,treat)],label=F, display="sites", kind = c("sd","se", "ehull"),
conf, draw = c("lines","polygon"), col = NULL, alpha = 127, show.groups,
label = FALSE, border = NULL, lty = NULL, lwd=NULL)}
ordiellipse(example_NMDS$point[grep(i,treat),],   groups=treat[treat==i], col=colors[grep(i,treat)],label=F, display="sites", kind = c("sd","se", "ehull"),
conf, draw = c("lines","polygon"), alpha = 127, show.groups,
label = FALSE, border = NULL, lty = NULL, lwd=NULL)}
ordiellipse(example_NMDS$point[grep(i,treat),],   groups=treat[treat==i], col=colors[grep(i,treat)],label=F, display="sites", kind = c("sd","se", "ehull"),
conf, draw = c("lines","polygon"))}
