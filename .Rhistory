# now add both the log of the weight and the column wfratio to the captures data frame, creating again new data frame called captures.new
captures %>%
mutate(logw = log(weight_g),
wfratio = weight_g/footlength_mm) -> captures.new
head(captures.new)
# select columns by name
captures %>%
select(weight_g, sex, age, footlength_mm)
# select all columns between weight and age
captures %>%
select(weight_g:age)
captures %>%
select(weight_g:footlength_mm)
# select columns from weight_g to footlenght_mm, excluding reproductive status
captures %>%
select(weight_g:footlength_mm) %>%
select(-repr_status)
captures %>%
group_by(sex) %>%
summarise(mean(weight_g, na.rm=TRUE))
captures %>%
group_by(sex) %>%
summarise(media_peso = mean(weight_g, na.rm=TRUE))
# sort the weigth of the animals
sort(captures$weight_g)
captures %>%
arrange(weight_g)
# DO IT ON YOUR OWN
?arrange
captures %>%
group_by(sex)  %>%
arrange(desc(weight_g), .by_group = TRUE)
captures %>%
group_by(sex) %>%
arrange(desc(weight_g))
# order according to weight and then to footlenght
captures %>%
arrange(desc(weight_g), footlength_mm)
## chi2 - goodness of fit test
freq <- c(22, 21, 22, 27, 22, 36)
probs <- rep(1/6, 6)
chisq.test(freq, p = probs)
## chi2 - test of independence
yesbelt <- c(12813, 647, 359, 42)
nobelt <- c(65963, 4000, 2642, 303)
chisq.test(data.frame(yesbelt, nobelt))
chisq.test(data.frame(yesbelt, nobelt))$exp
die.fair <- sample(1:6, 200, p=c(1,1,1,1,1,1)/6, replace = TRUE)
die.bias <- sample(1:6, 200, p=c(0.5,0.5,1,1,1,2)/6, replace = TRUE)
res.fair <- table(die.fair)
res.bias <- table(die.bias)
rbind(res.fair, res.bias)
chisq.test(rbind(res.fair, res.bias))
freq <- c(53, 22, 49)
probs <- c(5/12, 3/12, 4/12)
chisq.test(freq, p = probs)
r1 <- c(3,1)
r2 <- c(1,0)
chisq.test(data.frame(r1,r2)) -> Xsq
Xsq$observed   # observed counts (same as M)
Xsq$expected
Xsq
rbind(res.fair, res.bias)
# ?cars
summary(cars)
cars.lm <- lm(dist ~ speed, data = cars)
names(cars.lm)
coef(cars.lm)
plot(dist ~ speed, data = cars, pch = 16)
abline(coef(cars.lm), col="red", lwd=2)
summary(cars.lm)
dim(cars)
-17.58 + 3.93 * (8) # point estimate
cars[5,] # real data
fitted(cars.lm)
plot(dist ~ speed, data = cars, pch = 16)
fitted(cars.lm)
plot(dist ~ speed, data = cars, pch = 16)
abline(coef(cars.lm), col="red")
points(cars$speed, fitted(cars.lm), col="red", pch=19)
predict(cars.lm, newdata = data.frame(speed = c(6,8,21)))
plot(dist ~ speed, data = cars, pch = 16)
abline(coef(cars.lm), col="red")
points(cars$speed, fitted(cars.lm), col="red", pch=19)
points(c(6,8,21),
predict(cars.lm, newdata = data.frame(speed = c(6,8,21))),
col="blue", pch=19)
predict(cars.lm, newdata = data.frame(speed = c(0,6,8,21)))
plot(dist ~ speed, data = cars, pch = 16)
abline(coef(cars.lm), col="red")
points(cars$speed, fitted(cars.lm), col="red", pch=19)
points(c(6,8,21),
predict(cars.lm, newdata = data.frame(speed = c(6,8,21))),
col="blue", pch=19)
residuals(cars.lm)
# Residual standard error
carsumry <- summary(cars.lm)
summary(cars.lm)
carsumry$sigma
summary(cars.lm)
# new <- data.frame(speed = c(5,6,21))
# predict(cars.lm, newdata = new, interval = "confidence")
# predict(cars.lm, newdata = new, interval = "prediction")
library(HH)
ci.plot(cars.lm)
# or
# library(UsingR)
# simple.lm(cars$speed, cars$dist, show.ci=TRUE)
confint(cars.lm)
# new <- data.frame(speed = c(5,6,21))
# predict(cars.lm, newdata = new, interval = "confidence")
# predict(cars.lm, newdata = new, interval = "prediction")
library(HH)
ci.plot(cars.lm)
# or
# library(UsingR)
# simple.lm(cars$speed, cars$dist, show.ci=TRUE)
lm.result <- lm(growth ~ tannin)
growth = c(12, 10, 8, 11, 6, 7, 2, 3.5, 3.5)
tannin = 0:8
lm.result <- lm(growth ~ tannin)
summary(lm.result)
plot(growth ~ tannin)
abline(coef(lm.result), lwd=2, col="red")
confint(lm.result)
t = (-1.1583 - (-1.5))/0.2236
pt(t, 7, lower.tail = FALSE)
t = (-1.1583 - (-1.5))/0.2236
t
pt(t, 7, lower.tail = FALSE)
length(growth)
pt(t, 7)
pt(t, 7, lower.tail = FALSE)
data(cars)
cars.lm <- lm(dist ~ speed, data = cars)
coef(cars.lm)
names(cars.lm)
residuals(cars.lm)
residuals(cars.lm)
par(mfrow=c(1,3))
hist(residuals(cars.lm))
boxplot(residuals(cars.lm))
qqnorm(residuals(cars.lm))
qqline(residuals(cars.lm))
par(mfrow=c(1,1))
plot(cars.lm)
# install.packages("lmtest")
library(lmtest)
dwtest(cars.lm, alternative = "two.sided")
shapiro.test(residuals(cars.lm))
library(lmtest)
bptest(cars.lm)
data("trees")
head(trees)
hist(trees$Volume)
hist(trees$Volume^2)
hist(trees$Volume)
hist(trees$Volume^2)
library(MASS)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
seq(0, 0.5, length = 10)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees)
bctrans <- boxcox(Volume ~ Height + Girth, data = trees,
lambda = seq(0, 0.5, length = 10))
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
bctrans
which(bctrans$y==max(bctrans$y))
bctrans$x[62]
hist(trees$Volume)
hist(trees$Volume^0.31)
# load the data
data(trees) # this is a dataframe
class(trees)
# histograms
hist(trees$Girth)
hist(trees$Height)
hist(trees$Volume)
# boxplots
boxplot(trees$Girth)
boxplot(trees$Height)
boxplot(trees$Volume)
# normality test
shapiro.test(trees$Girth)
qqnorm(trees$Girth); qqline(trees$Girth)
data("trees")
mod <- lm(Volume ~ Girth + Height, data=trees)
summary(mod)
# the mean increase in volume when there is a one-unit increase in girth is 4.7
# Volume.tr <- trees$Volume^0.30
# mod.tr <- lm(Volume.tr ~ Girth + Height, data=trees)
# summary(mod.tr)
plot(Volume ~ Girth, data=trees)
mod.q <- lm(Volume ~ Girth + I(Girth^2) +
Height + I(Height^2),
data=trees)
summary(mod.q)
plot(Volume ~ Girth, data=trees)
summary(mod.q)
# alternative code:
mod.q <- lm(Volume ~ poly(Girth, 2, raw=TRUE) + poly(Height, 2, raw=TRUE), data=trees)
summary(mod.q)
plot(Volume ~ Girth, data=trees)
mod.q <- lm(Volume ~ Girth + I(Girth^2) + Height , data=trees)
summary(mod.q)
mod.int <- lm(Volume ~ Girth * Height, data=trees)
summary(mod.int)
mod <- lm(Volume ~ Girth + Height, data=trees)
plot(mod)
plot(trees$Volume ~ trees$Girth)
plot(trees$Volume ~ trees$Height)
mod <- lm(Volume ~ Girth * Height, data=trees)
plot(mod)
plot(trees$Volume ~ trees$Girth)
plot(trees$Volume ~ trees$Height)
library(sjPlot)
# plot_model(mod)
plot_model(mod, type = "eff", terms = "Girth")
plot_model(mod, type = "eff", terms = "Height")
plot_model(mod.int, type = "eff", terms = "Height")
plot_model(mod.int, type = "int", terms = c("Height","Girth")) # # type = "int" automatically selects groups for continuous moderator variables
library(jtools)
effect_plot(mod.int, pred = Girth, interval = TRUE)
plot_model(mod.int, type = "pred", terms = c("Girth", "Height [60,80]"))
# switch moderator
plot_model(mod.int, type = "pred", terms = c("Height", "Girth"))
library(MASS)
data(cats)
library(car)
library(dplyr)
library(ggcorrplot)
# Load the data
data("Boston", package = "MASS")
# Split the data into training and test set
# set.seed(123)
# training.samples <- Boston$medv %>%
#   createDataPartition(p = 0.8, list = FALSE)
# train.data  <- Boston[training.samples, ]
# test.data <- Boston[-training.samples, ]
head(Boston)
pred <- dplyr::select(Boston, crim:lstat)
names(pred)
cor.matrix <- cor(pred)
cor.matrix
ggcorrplot(cor.matrix)
ggcorrplot(cor.matrix, method = "circle")
ggcorrplot(cor.matrix, method = "circle", lab=TRUE)
p.mat <- (abs(cor.matrix) > 0.7)
p.mat
# Argument p.mat
# Barring the significant coefficients
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
# Build the model
model1 <- lm(medv ~ ., data = Boston)
summary(model1)
vif(model1)
pollution <- read.table("data/sulphur.dioxide.txt", header=TRUE)
pairs(pollution,panel=panel.smooth)
cor.matrix <- cor(pollution)
# cor.matrix
p.mat <- (abs(cor.matrix) > 0.7)
# p.mat
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
# Build the model
model1 <- lm(Pollution ~ ., data = pollution)
summary(model1)
vif(model1)
model1 <- lm(Pollution ~ Temp + Industry + Wind + Rain + Wet.days, data = pollution)
summary(model1)
knitr::opts_chunk$set(echo = TRUE)
# dati <- read.csv("slides/data/captures.csv", sep=";")[,c("capture_id","weight_g","sex","age")]
dati <- read.csv("data/captures.csv", sep=";")[,c("capture_id","weight_g","sex","age")]
dati <- na.omit(dati)
dati$classe <- paste(dati$sex,dati$age)
# head(dati)
dati$classe[dati$classe=="F G"] <- "M G"
myData.mean <- aggregate(na.omit(dati$weight_g),
by = list(factor(dati$classe)),
FUN = 'mean')
boxplot(dati$weight_g ~ dati$classe, varwidth = TRUE)
par(mfrow=c(1,2))
dotchart(dati$weight_g,
ylab = "Order of observations",
xlab = "Weight", main = "")
dotchart(dati$weight_g,
groups = factor(dati$classe),
ylab = "Age/sex class",
xlab = "Weight", main = "")
par(mfrow=c(1,1))
pairs(iris[1:4], pch = 21)
data(cars)
cars.lm <- lm(dist ~ speed, data = cars)
par(mfrow=c(2,2))
plot(cars.lm)
par(mfrow=c(1,1))
# dati <- read.csv("slides/data/catture-trappola.csv", sep=";")
dati <- read.csv("data/catture-trappola.csv", sep=";")
dati.mod <- read.csv("data/dati.mod.csv")
head(dati.mod)
varexpl <- dati.mod[,8:15]
head(varexpl)
hist(dati.mod$CattSiNo)
table(dati.mod$CattSiNo)
summary(varexpl)
with(dati.mod,
boxplot(Incl ~ CattSiNo, main="Slope"))
with(dati.mod,
boxplot(Alt ~ CattSiNo, main="Altitude"))
with(dati.mod,
boxplot(copveg ~ CattSiNo, main="Veg cover"))
with(dati.mod,
boxplot(NSpecie ~ CattSiNo, main="N species"))
with(dati.mod,
boxplot(media.rocce ~ CattSiNo, main="Mean diam"))
with(dati.mod,
boxplot(mediana.rocce ~ CattSiNo, main="Median diam"))
with(dati.mod,
boxplot(sd.rocce ~ CattSiNo, main="SD diam"))
with(dati.mod,
boxplot(Esp.tr ~ CattSiNo, main="Aspect"))
par(mfrow=c(1,2))
dotchart(dati.mod$sd.rocce,
ylab = "Order of observations",
xlab = "SD diam", main = "")
dotchart(dati.mod$sd.rocce,
groups = dati.mod$CattSiNo,
ylab = "CattSiNo",
xlab = "SD diam", main = "")
par(mfrow=c(1,1))
# eliminazione dell'outlier
subset(dati.mod, dati.mod$sd.rocce > 200)
dati.mod.new <- subset(dati.mod, dati.mod$sd.rocce < 200)
# trasformazione della variabile x
boxplot(dati.mod$sd.rocce)
boxplot(log(dati.mod$sd.rocce))
dati.mod.new2 <- cbind(dati.mod, logSD = log(dati.mod$sd.rocce))
dati.mod.new2 <- data.frame(dati.mod, logSD = log(dati.mod$sd.rocce))
head(dati.mod.new2)
cor(varexpl)
fm1 <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce +
Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1)
hist(dati.mod.new$Ncatture)
fm1.pois <- glm(Ncatture ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce +
Esp.tr,
family=poisson, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.pois)
# UP TO YOU!!!
fm1.noexp <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce, #+
#sd.rocce, #
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.noexp)
fm2 <- glm(CattSiNo ~ #Incl +
Alt +
# copveg +
# NSpecie +
media.rocce, #+
# mediana.rocce +
# sd.rocce +
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm2)
par(mfrow=c(1,2))
termplot(fm2, se=TRUE, col.term = "red", col.se = "grey",
ylabs = rep("odds ratio",2),
main = c("Alt","Mean diam"), cex.main = 0.7)
par(mfrow=c(1,1))
library(popbio)
logi.hist.plot(dati.mod.new$Alt,dati.mod.new$CattSiNo,boxp=FALSE,type="hist",col="gray")
logi.hist.plot(dati.mod.new$media.rocce,dati.mod.new$CattSiNo,boxp=FALSE,type="hist",col="gray")
logi.hist.plot(dati.mod.new$Esp.tr,dati.mod.new$CattSiNo,boxp=FALSE,type="hist",col="gray")
logit2prob <- function(logit){
odds <- exp(logit)
prob <- odds / (1 + odds)
return(prob)
}
logit2prob(coef(fm2))
predict.alt <- predict(fm2,
data.frame(Alt=dati.mod.new$Alt,
media.rocce=mean(dati.mod.new$media.rocce)),
type = "response")
tab <- data.frame(Alt=dati.mod.new$Alt,
prob = predict.alt)
# tab
library(dplyr)
arrange(tab, Alt)
plot(arrange(tab, Alt))
library(sjPlot)
plot_model(fm2, type = "pred")
plot_model(fm2)
citation()
RStudio.Version()
library(MASS)
data(cats)
head(cats)
str(cats)
plot(cats$Bwt, cats$Hwt)
plot(cats$Bwt ~ cats$Hwt)
plot(Bwt ~ Hwt, data = cats)
plot(cats$Bwt, cats$Hwt)
plot(Hwt ~ Bwt, data = cats)
cor(cats$Bwt, cats$Hwt)
cor.test(cats$Bwt, cats$Hwt)
cor.test(cats$Hwt, cats$Bwt)
plot(Hwt ~ Bwt, data = cats)
plot(Bwt ~ Hwt, data = cats)
mod <- lm(Hwt ~ Bwt, data=cats)
summary(mod)
lm(Hwt ~ Bwt, data=cats)
summary(mod)
plot(cats$Bwt, cats$Hwt)
abline(coef(mod), col="red")
par(mfrow=c(2,2))
plot(mod)
par(mfrow=c(1,4))
plot(mod)
par(mfrow=c(2,2))
plot(mod)
par(mfrow=c(1,1))
plot(mod)
library(car)
library(dplyr)
library(ggcorrplot)
# Load the data
data("Boston", package = "MASS")
# Split the data into training and test set
# set.seed(123)
# training.samples <- Boston$medv %>%
#   createDataPartition(p = 0.8, list = FALSE)
# train.data  <- Boston[training.samples, ]
# test.data <- Boston[-training.samples, ]
head(Boston)
pred
ggcorrplot(cor(pred))
ggcorrplot(cor.matrix, method = "circle", lab=TRUE)
p.mat <- (abs(cor.matrix) > 0.7)
p.mat
library(car)
library(dplyr)
library(ggcorrplot)
# Load the data
data("Boston", package = "MASS")
# Split the data into training and test set
# set.seed(123)
# training.samples <- Boston$medv %>%
#   createDataPartition(p = 0.8, list = FALSE)
# train.data  <- Boston[training.samples, ]
# test.data <- Boston[-training.samples, ]
head(Boston)
pred <- dplyr::select(Boston, crim:lstat)
names(pred)
pred
cor.matrix <- cor(pred)
cor.matrix
ggcorrplot(cor.matrix)
ggcorrplot(cor(pred))
ggcorrplot(cor.matrix, method = "circle")
ggcorrplot(cor.matrix, method = "circle", lab=TRUE)
p.mat <- (abs(cor.matrix) > 0.7)
p.mat
# Build the model
model1 <- lm(medv ~ ., data = Boston)
summary(model1)
vif(model1)
pollution <- read.table("data/sulphur.dioxide.txt", header=TRUE)
View(pollution)
cor.matrix <- cor(pollution)
cor.matrix
p.mat <- (abs(cor.matrix) > 0.7)
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
# Build the model
model1 <- lm(Pollution ~ ., data = pollution)
summary(model1)
vif(model1)
vif(model1)
model1 <- lm(Pollution ~ Temp + Industry + Wind + Rain + Wet.days, data = pollution)
summary(model1)
