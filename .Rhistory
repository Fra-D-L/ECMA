pairs(pollution,panel=panel.smooth)
library(car)
library(dplyr)
library(ggcorrplot)
# Load the data
data("Boston", package = "MASS")
# Split the data into training and test set
# set.seed(123)
# training.samples <- Boston$medv %>%
#   createDataPartition(p = 0.8, list = FALSE)
# train.data  <- Boston[training.samples, ]
# test.data <- Boston[-training.samples, ]
head(Boston)
pred <- dplyr::select(Boston, crim:lstat)
names(pred)
cor.matrix <- cor(pred)
cor.matrix
ggcorrplot(cor.matrix)
ggcorrplot(cor.matrix, method = "circle")
ggcorrplot(cor.matrix, method = "circle", lab=TRUE)
p.mat <- (cor.matrix > 0.7)
p.mat
# Argument p.mat
# Barring the significant coefficients
ggcorrplot(cor.matrix,
hc.order = TRUE, method = "circle",
type = "lower", p.mat = p.mat
)
# Build the model
model1 <- lm(medv ~., data = Boston)
summary(model1)
vif(model1)
pollution <- read.table("data/sulphur.dioxide.txt", header=TRUE)
pairs(pollution,panel=panel.smooth)
dati.mod <- read.csv("data/dati.mod.csv")
head(dati.mod)
varexpl <- dati.mod[,8:15]
head(varexpl)
hist(dati.mod$CattSiNo)
table(dati.mod$CattSiNo)
summary(varexpl)
with(dati.mod,
boxplot(Incl ~ CattSiNo, main="Slope"))
with(dati.mod,
boxplot(Alt ~ CattSiNo, main="Altitude"))
with(dati.mod,
boxplot(copveg ~ CattSiNo, main="Veg cover"))
with(dati.mod,
boxplot(NSpecie ~ CattSiNo, main="N species"))
with(dati.mod,
boxplot(media.rocce ~ CattSiNo, main="Mean diam"))
with(dati.mod,
boxplot(mediana.rocce ~ CattSiNo, main="Median diam"))
with(dati.mod,
boxplot(sd.rocce ~ CattSiNo, main="SD diam"))
with(dati.mod,
boxplot(Esp.tr ~ CattSiNo, main="Aspect"))
par(mfrow=c(1,2))
dotchart(dati.mod$sd.rocce,
ylab = "Order of observations",
xlab = "SD diam", main = "")
dotchart(dati.mod$sd.rocce,
groups = dati.mod$CattSiNo,
ylab = "CattSiNo",
xlab = "SD diam", main = "")
par(mfrow=c(1,1))
# eliminazione dell'outlier
subset(dati.mod, dati.mod$sd.rocce > 200)
dati.mod.new <- subset(dati.mod, dati.mod$sd.rocce < 200)
# trasformazione della variabile x
boxplot(dati.mod$sd.rocce)
boxplot(log(dati.mod$sd.rocce))
dati.mod.new2 <- cbind(dati.mod, logSD = log(dati.mod$sd.rocce))
dati.mod.new2 <- data.frame(dati.mod, logSD = log(dati.mod$sd.rocce))
head(dati.mod.new2)
cor(varexpl)
fm1 <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce +
Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1)
hist(dati.mod.new$Ncatture)
fm1.pois <- glm(Ncatture ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce +
Esp.tr,
family=poisson, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.pois)
# UP TO YOU!!!
fm1.noexp <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce, #+
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.noexp)
fm2 <- glm(CattSiNo ~ #Incl +
Alt +
# copveg +
# NSpecie +
media.rocce, #+
# mediana.rocce +
# sd.rocce +
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm2)
par(mfrow=c(1,2))
termplot(fm2, se=TRUE, col.term = "red", col.se = "grey",
ylabs = rep("odds ratio",2),
main = c("Alt","Mean diam"), cex.main = 0.7)
par(mfrow=c(1,1))
# UP TO YOU!!!
fm1.noexp <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce, #+
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.noexp)
dati.mod <- read.csv("data/dati.mod.csv")
head(dati.mod)
varexpl <- dati.mod[,8:15]
head(varexpl)
hist(dati.mod$CattSiNo)
table(dati.mod$CattSiNo)
summary(varexpl)
with(dati.mod,
boxplot(Incl ~ CattSiNo, main="Slope"))
with(dati.mod,
boxplot(Alt ~ CattSiNo, main="Altitude"))
with(dati.mod,
boxplot(copveg ~ CattSiNo, main="Veg cover"))
with(dati.mod,
boxplot(NSpecie ~ CattSiNo, main="N species"))
with(dati.mod,
boxplot(media.rocce ~ CattSiNo, main="Mean diam"))
with(dati.mod,
boxplot(mediana.rocce ~ CattSiNo, main="Median diam"))
with(dati.mod,
boxplot(sd.rocce ~ CattSiNo, main="SD diam"))
with(dati.mod,
boxplot(Esp.tr ~ CattSiNo, main="Aspect"))
par(mfrow=c(1,2))
dotchart(dati.mod$sd.rocce,
ylab = "Order of observations",
xlab = "SD diam", main = "")
dotchart(dati.mod$sd.rocce,
groups = dati.mod$CattSiNo,
ylab = "CattSiNo",
xlab = "SD diam", main = "")
par(mfrow=c(1,1))
# eliminazione dell'outlier
subset(dati.mod, dati.mod$sd.rocce > 200)
dati.mod.new <- subset(dati.mod, dati.mod$sd.rocce < 200)
# trasformazione della variabile x
boxplot(dati.mod$sd.rocce)
boxplot(log(dati.mod$sd.rocce))
dati.mod.new2 <- cbind(dati.mod, logSD = log(dati.mod$sd.rocce))
dati.mod.new2 <- data.frame(dati.mod, logSD = log(dati.mod$sd.rocce))
head(dati.mod.new2)
cor(varexpl)
fm1 <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce +
Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1)
hist(dati.mod.new$Ncatture)
fm1.pois <- glm(Ncatture ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce +
Esp.tr,
family=poisson, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.pois)
# UP TO YOU!!!
fm1.noexp <- glm(CattSiNo ~ Incl +
Alt +
copveg +
# NSpecie +
# media.rocce +
mediana.rocce +
sd.rocce, #+
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm1.noexp)
fm2 <- glm(CattSiNo ~ #Incl +
Alt +
# copveg +
# NSpecie +
media.rocce, #+
# mediana.rocce +
# sd.rocce +
# Esp.tr,
family=binomial, data=dati.mod.new)
#, offset=Noccasioni)
summary(fm2)
par(mfrow=c(1,2))
termplot(fm2, se=TRUE, col.term = "red", col.se = "grey",
ylabs = rep("odds ratio",2),
main = c("Alt","Mean diam"), cex.main = 0.7)
par(mfrow=c(1,1))
library(popbio)
logi.hist.plot(dati.mod.new$Alt,dati.mod.new$CattSiNo,boxp=FALSE,type="hist",col="gray")
logi.hist.plot(dati.mod.new$media.rocce,dati.mod.new$CattSiNo,boxp=FALSE,type="hist",col="gray")
logi.hist.plot(dati.mod.new$Esp.tr,dati.mod.new$CattSiNo,boxp=FALSE,type="hist",col="gray")
logit2prob <- function(logit){
odds <- exp(logit)
prob <- odds / (1 + odds)
return(prob)
}
logit2prob(coef(fm2))
predict.alt <- predict(fm2, data.frame(Alt=dati.mod.new$Alt,
media.rocce=mean(dati.mod.new$media.rocce)),
type = "response")
tab <- data.frame(Alt=dati.mod.new$Alt,
prob = predict.alt)
# tab
library(dplyr)
arrange(tab, Alt)
plot(arrange(tab, Alt))
library(sjPlot)
plot_model(fm2, type = "pred")
plot_model(fm2)
knitr::opts_chunk$set(echo = TRUE)
res.prcomp <- prcomp(iris[,-5])
summary(res.prcomp)
# compare to:
res.prcomp <- prcomp(iris[,-5], center=TRUE, scale=TRUE)
summary(res.prcomp)
plot(res.prcomp)
biplot(res.prcomp)
res.prcomp$rotation
biplot(res.prcomp, choices=3:4)
res.princomp <- princomp(iris[,-5])
summary(res.princomp)
# compare to:
res.princomp <- princomp(iris[,-5], cor=TRUE)
summary(res.princomp)
loadings(res.princomp) # Small loadings are conventionally not printed (replaced by spaces), to draw the eye to the pattern of the larger loadings.
# A matrix of loadings, one column for each factor. The factors are ordered in decreasing order of sums of squares of loadings, and given the sign that will make the sum of the loadings positive.
# The signs of the loadings vectors are arbitrary
# Calling loadings() on your object returns a summary where the SS are always equal to 1, hence the % variance is just the SS loadings divided by the number of variables. It makes sense only when using Factor Analysis - don't look at this table for PCA!!
plot(res.princomp)
biplot(res.princomp)
varimax(res.princomp$loadings[,1:2])
# Varimax is so called because it maximizes the sum of the variances of the squared loadings (squared correlations between variables and factors).
# After an orthogonal rotation (such as varimax), the "rotated-principal" axes are not orthogonal, and orthogonal projections on them do not make sense. So one should rather drop this whole axes/projections point of view. It would be weird to still call it PCA (which is all about projections with maximal variance etc.).
library(FactoMineR)
library(factoextra)
res.pca <- PCA(iris[, -5],  graph = FALSE)
res.pca
get_eig(res.pca) # Extract eigenvalues/variances
sqrt(get_eig(res.pca)[,1]) # compare to summary(res.prcomp)
# Visualize eigenvalues/variances
fviz_eig(res.pca, addlabels=TRUE, hjust = -0.3)+
theme_minimal()
# export all results in csv file
write.infile(res.pca,file="my_FactoMineR_results.csv")
# Extract the results for variables
var <- get_pca_var(res.pca)
var
# Contribution of variables
var$contrib
colSums(var$contrib)
# correlation of variables with the first 4 PC
res.pca$var$cor[, 1:4]
# axis characterization
dimdesc(res.pca)
# Graph of variables: default plot
fviz_pca_var(res.pca, col.var = "steelblue")
# Itâ€™s possible to control variable colors using their contributions to the principal axes:
# Control variable colors using their contributions
# Use gradient color
fviz_pca_var(res.pca, col.var="contrib")+
scale_color_gradient2(low="white", mid="blue",
high="red", midpoint = 96) +
theme_minimal()
# Variable contributions on axis 1
fviz_contrib(res.pca, choice="var", axes = 1 )+
labs(title = "Contributions to Dim 1")
# Variable contributions on axis 2
fviz_contrib(res.pca, choice="var", axes = 2 )+
labs(title = "Contributions to Dim 2")
# Variable contributions on axes 1 + 2
fviz_contrib(res.pca, choice="var", axes = 1:2)+
labs(title = "Contributions to Dim 1+2")
# Extract the results for individuals
ind <- get_pca_ind(res.pca)
ind
# Coordinates of individuals
head(ind$coord)
# compare to:
head(res.prcomp$x)
# Graph of individuals
# 1. Use repel = TRUE to avoid overplotting
fviz_pca_ind(res.pca, repel = TRUE)+
theme_minimal()
# Color by groups: habillage=iris$Species
# Show points only: geom = "point"
p <- fviz_pca_ind(res.pca, geom = "point",
habillage=iris$Species, addEllipses=TRUE,
ellipse.level= 0.95)+ theme_minimal()
print(p)
# Change group colors manually
# Read more: http://www.sthda.com/english/wiki/ggplot2-colors
p + scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
theme_minimal()
# Biplot of individuals and variables
# ++++++++++++++++++++++++++
# Only variables are labelled
fviz_pca_biplot(res.pca,  label="var", habillage=iris$Species,
addEllipses=TRUE, ellipse.level=0.95) +
theme_minimal()
dim(df.new)
# dim(df.new)
length(var$coord)
dim(iris)
mod1 <- aov()
# dim(df.new)
length(var$coord)
dim(iris)
# mod1 <- aov()
res.pca$var$coord
# Transpose eigeinvectors
eigenvectors.t <- t(res.eig$vectors)
# Non-metric multidimensional scaling (NMDS) is one tool commonly used to
# examine community composition
# # Let's lay some conceptual groundwork
# # Consider a single axis of abundance representing a single species:
# plot(0:10,0:10,type="n",axes=F,xlab="Abundance of Species 1",ylab="")
# axis(1)
# # We can plot each community on that axis depending on the abundance of
# # species 1 within it
# points(5,0); text(5.5,0.5,labels="community A")
# points(3,0); text(3.2,0.5,labels="community B")
# points(0,0); text(0.8,0.5,labels="community C")
#
# # Now consider a second axis of abundance representing a different
# # species
# # Communities can be plotted along both axes depending on the abundance of
# # species within it
# plot(0:10,0:10,type="n",xlab="Abundance of Species 1",
#      ylab="Abundance of Species 2")
# points(5,5); text(5,4.5,labels="community A")
# points(3,3); text(3,3.5,labels="community B")
# points(0,5); text(0.8,5.5,labels="community C")
# Now consider a THIRD axis of abundance representing yet another species
# (For this we're going to need to load another package)
# install.packages("scatterplot3d")
library(scatterplot3d)
d=scatterplot3d(0:10,0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2",
zlab="Abundance of Species 3"); d
d$points3d(5,5,0); text(d$xyz.convert(5,5,0.5),labels="community A")
d$points3d(3,3,3); text(d$xyz.convert(3,3,3.5),labels="community B")
d$points3d(0,5,5); text(d$xyz.convert(0,5,5.5),labels="community C")
# Now consider as many axes as there are species S (obviously we cannot
# visualize this beyond 3 dimensions)
# Hopefully your head didn't explode
# Non-metric multidimensional scaling (NMDS) is one tool commonly used to
# examine community composition
# # Let's lay some conceptual groundwork
# # Consider a single axis of abundance representing a single species:
# plot(0:10,0:10,type="n",axes=F,xlab="Abundance of Species 1",ylab="")
# axis(1)
# # We can plot each community on that axis depending on the abundance of
# # species 1 within it
# points(5,0); text(5.5,0.5,labels="community A")
# points(3,0); text(3.2,0.5,labels="community B")
# points(0,0); text(0.8,0.5,labels="community C")
#
# # Now consider a second axis of abundance representing a different
# # species
# # Communities can be plotted along both axes depending on the abundance of
# # species within it
plot(0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2")
points(5,5); text(5,4.5,labels="community A")
points(3,3); text(3,3.5,labels="community B")
points(0,5); text(0.8,5.5,labels="community C")
# Now consider a THIRD axis of abundance representing yet another species
# (For this we're going to need to load another package)
# install.packages("scatterplot3d")
library(scatterplot3d)
d=scatterplot3d(0:10,0:10,0:10,type="n",xlab="Abundance of Species 1",
ylab="Abundance of Species 2",
zlab="Abundance of Species 3"); d
d$points3d(5,5,0); text(d$xyz.convert(5,5,0.5),labels="community A")
d$points3d(3,3,3); text(d$xyz.convert(3,3,3.5),labels="community B")
d$points3d(0,5,5); text(d$xyz.convert(0,5,5.5),labels="community C")
# Now consider as many axes as there are species S (obviously we cannot
# visualize this beyond 3 dimensions)
# Hopefully your head didn't explode
# To run the NMDS, we will use the function `metaMDS` from the vegan
# package
#install.packages("vegan")
library(vegan)
# `metaMDS` requires a community-by-species matrix
# Let's create that matrix with some randomly sampled data
set.seed(2)
community_matrix=matrix(sample(1:100,300,replace=T),nrow=10,
dimnames=list(paste("community",1:10,sep=""),
paste("sp",1:30,sep="")))
community_matrix
# The function `metaMDS` will take care of most of the distance
# calculations, iterative fitting, etc. We need simply to supply:
example_NMDS=metaMDS(community_matrix, # Our community-by-species matrix
k=2) # The number of reduced dimensions
# You should see each iteration of the NMDS until a solution is reached
# (i.e., stress was minimized after some number of reconfigurations of
# the points in 2 dimensions). You can increase the number of default
# iterations using the argument "trymax=##"
example_NMDS=metaMDS(community_matrix,k=2,trymax=100)
# And we can look at the NMDS object
example_NMDS # metaMDS has automatically applied a square root
# transformation and calculated the Bray-Curtis distances for our
# community-by-site matrix
# Let's examine a Shepard plot, which shows scatter around the regression
# between the interpoint distances in the final configuration (distances
# between each pair of communities) against their original dissimilarities
stressplot(example_NMDS)
#Now we can plot the NMDS
plot(example_NMDS)
#Now we can plot the NMDS
plot(example_NMDS)
# It shows us both the communities ("sites", open circles) and species
# (red crosses), but we  don't know which are which!
# We can use the functions `ordiplot` and `orditorp` to add text to the
# plot in place of points
ordiplot(example_NMDS,type="n")
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",cex=1.25,air=0.01)
# There are some additional functions that might of interest
# Let's suppose that communities 1-5 had some treatment applied, and
# communities 6-10 a different treatment
# We can draw convex hulls connecting the vertices of the points made by
# these communities on the plot
# First, let's create a vector of treatment values:
treat=c(rep("Treatment1",5),rep("Treatment2",5))
ordiplot(example_NMDS,type="n")
ordihull(example_NMDS,groups=treat,draw="polygon",col="grey90",
label=FALSE)
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",col=c(rep("green",5),rep("blue",5)),
air=0.01,cex=1.25)
# I find this an intuitive way to understand how communities and species
# cluster based on treatments
# One can also plot ellipses and "spider graphs" using the functions
# `ordiellipse` and `orderspider` which emphasize the centroid of the
# communities in each treatment
# Another alternative is to plot a minimum spanning tree (from the
# function `hclust`), which clusters communities based on their original
# dissimilarities and projects the dendrogram onto the 2-D plot
ordiplot(example_NMDS,type="n")
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",col=c(rep("green",5),rep("blue",5)),
air=0.01,cex=1.25)
ordicluster(example_NMDS,hclust(vegdist(community_matrix,"bray")))
# Note that clustering is based on Bray-Curtis distances
# This is one method suggested to check the 2-D plot for accuracy
# You could also plot the convex hulls, ellipses, spider plots, etc. colored based on the treatments
# First, create a vector of color values corresponding of the same length as the vector of treatment values
colors=c(rep("red",5),rep("blue",5))
ordiplot(example_NMDS,type="n")
#Plot convex hulls with colors baesd on treatment
for(i in unique(treat)) {
ordihull(example_NMDS$point[grep(i,treat),],draw="polygon",groups=treat[treat==i],col=colors[grep(i,treat)],label=F) }
orditorp(example_NMDS,display="species",col="red",air=0.01)
orditorp(example_NMDS,display="sites",col=c(rep("green",5),rep("blue",5)),
air=0.01,cex=1.25)
# If the treatment is a continuous variable, consider mapping contour
# lines onto the plot
# For this example, consider the treatments were applied along an
# elevational gradient
# We can define random elevations for previous example
elevation=runif(10,0.5,1.5)
# And use the function ordisurf to plot contour lines
ordisurf(example_NMDS,elevation,main="",col="forestgreen")
# Finally, we want to display species on plot
orditorp(example_NMDS,display="species",col="grey30",air=0.1,cex=1)
